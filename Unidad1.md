[ğŸ”™ Volver a la Portada Principal](index.md)

## ğŸš€ UNIDAD 1: Fundamentos de la ProgramaciÃ³n y Algoritmos

ğŸ’¡ Â¡El punto de partida de todo programador! Esta unidad fue clave para aprender a "pensar" antes de "codificar".

<p align="center"><img width="300" height="300" alt="image" src="https://github.com/user-attachments/assets/558ba8d8-f318-4c08-be88-4f4c20fc589a" />

---

### ğŸ§  Contenidos de la Unidad

#### ğŸ—ºï¸ 1. Algoritmos, PseudocÃ³digo y Diagramas de Flujo

Conceptos base
 * **Algoritmo:** La "receta" ğŸ³. Es una secuencia de pasos lÃ³gicos, finitos y claros que dan soluciÃ³n a un problema determinado.

 **ğŸ—‚ï¸ ClasificaciÃ³n:**
 * **ğŸ—£ï¸ Cualitativos:** La descripciÃ³n es a travÃ©s de frases y palabras.

   Ejemplo:
   
   **Algoritmo para la suma de dos nÃºmeros**
   1. Inicio.
   2. Obtener el primer nÃºmero.
   3. Obtener el segundo nÃºmero.
   4. Sumar los dos nÃºmeros.
   5. Mostrar el resultado de la suma.
   6. Fin.
   
 * **ğŸ”¢ Cuantitativos:** Implica el uso de cÃ¡lculos o fÃ³rmulas matemÃ¡ticas.

   Ejemplo:

   **Preparar una taza de cafÃ©**
   1. Inicio.
   2. Toma una taza y una cucharada.
   3. Pon cafÃ© instantÃ¡neo en la taza.
   4. Hierve agua en una tetera.
   5. Vierte el agua caliente en la taza, sin llenarla por completo.
   6. Remueve con la cucharada hasta disolver el cafÃ©.
   7. AÃ±ade azÃºcar o leche al gusto.
   8. Fin.

 **ğŸ§© Partes:**
 * **ğŸ“¥ Las entradas:** se refiere a todos los datos, valores, variables o constantes iniciales que el algoritmo necesita para empezar a trabajar.
   
   * **ğŸ§© Tipos de datos para las entradas:**
     Un dato es una cifra, letra, palabra... que se suministra a la computadora como entrada y la mÃ¡quina almacena en un determinado formato

     Datos simples:
     
      * **Enteros (int):** valores que NO tienen punto decimal o flotante y pueden ser positivos o negativos.
      * **Reales (float o double):** valores que SI tienen punto decimal o flotante y pueden ser positivos o negativos.
      * **CarÃ¡cter (char):** conformado por un solo carÃ¡cter que va entre comillas y pueden ser letras, nÃºmeros, signos o sÃ­mbolos.
      * **LÃ³gicos (boolean):** solo se almacenan dos tipos de datos: falso o verdadero.
        
     Datos compuestos:
     
      * **Cadenas (string):** combinaciÃ³n de los caracteres forma una cadena.
   
   * **ğŸ§© Identificadores:**
     Es un nombre asociado a un objeto de programa, puede ser una variable, una constante, una funciÃ³n...
     
      * **Variables:**
        Guardan un valor, que puede ser modificado durante la ejecuciÃ³n del programa. Se declaran al inicio del programa, y antes de que se utilicen en las operaciones. Deben poseer un nombre. tipo de dato y valor inicial (opcional).
      * **Constantes:**
        Guardan un valor, pero que NO van a cambiar durante la ejecuciÃ³n del programa. Se escribe en MAYÃšSCULAS.

   * **ğŸ§© AsignaciÃ³n:** Es la acciÃ³n de darle valor a una variable o constante. Se utiliza el signo â† o = como sÃ­mbolo de asignaciÃ³n.

     Ejemplo:

              nota1 â† 5

              suma â† valor1 + valor2
     
*En PseInt se usa el comando "Leer variable", para que los usuarios ingresen datos*

* **âš™ï¸ Los procesos:** es el conjunto de pasos, instrucciones o procedimientos lÃ³gicos que el algoritmo sigue para manipular los datos de entrada y transformarlos en el resultado deseado.

* **ğŸ“¤ Las salidas:** es el resultado final o la soluciÃ³n que produce el algoritmo despuÃ©s de haber ejecutado todo el proceso.
  
*En PseInt se usa el comando "Escribir", para mostrar a los usuarios los resultados*

<p align="center"><img width="409" height="103" alt="image" src="https://github.com/user-attachments/assets/285ff54e-7747-4192-9c37-cd9f4e02b50a" />

<p align="center"><em><b>Figura 1:</b> Partes de un algoritmo.</em>
</p>

***Nota: los comentarios de codificaciÃ³n son mensajes que sirven para documentar el cÃ³digo. No son tomados en cuenta al momento de ejecutarse el algoritmo.***

 **ğŸ—‚ï¸ Expresiones:**
 Son una combinaciÃ³n entre variables, constantes, operadores y parÃ©ntesis.
 
 **Tipos:**
 
 * **ğŸ—£ï¸ Operadores aritmÃ©ticos o matemÃ¡ticos:**
<p align="center"><img width="741" height="259" alt="image" src="https://github.com/user-attachments/assets/a71f6ba1-d691-455d-8d84-1378f6f8df30" />

<p align="center"><em><b>Figura 2:</b> Operadores aritmÃ©ticos o matemÃ¡ticos.</em>
</p>

 * **ğŸ—£ï¸ Operadores relacionales:**
<p align="center"><img width="767" height="230" alt="image" src="https://github.com/user-attachments/assets/41d5d0bc-ecf4-42f5-8227-b3e6f13bd702" />

<p align="center"><em><b>Figura 3:</b> Operadores relacionales.</em>
</p>

 * **ğŸ—£ï¸ Operadores lÃ³gicos:**
<p align="center"><img width="817" height="166" alt="image" src="https://github.com/user-attachments/assets/ff06985d-a104-4d2b-a54e-1549e8dd48f3" />

<p align="center"><em><b>Figura 4:</b> Operadores lÃ³gicos.</em>
</p>

**Prioridad de resoluciÃ³n:**
<p align="center"><img width="645" height="296" alt="image" src="https://github.com/user-attachments/assets/163ab2cb-8dbc-45a3-a999-e2503563ae13" />

<p align="center"><em><b>Figura 5:</b>Orden de resoluciÃ³n de los tipos de operadores.</em>
</p>

---

**ğŸ¨ Formas de representar y verificar un algoritmo:**

* **PseudocÃ³digo:** El "borrador" ğŸ“. Son instrucciones escritas bajo cierta estructura y reglas que inducirÃ¡n a los principiantes hacia los lenguajes de programaciÃ³n. Consiste en escribir el algoritmo en un lenguaje simple, casi humano, pero estructurado.
    
* **Diagrama de Flujo:** El "mapa" ğŸ—ºï¸. Utiliza sÃ­mbolos y describen las instrucciones que debe seguir el algoritmo.
    
<p align="center"><img width="568" height="624" alt="image" src="https://github.com/user-attachments/assets/f5af823b-d4cd-4b3b-831d-5906485720ae" />

<p align="center"><em><b>Figura 6:</b> SÃ­mbolos mÃ¡s usados para representar algoritmos.</em>
</p>

* **Pruebas de escritorio:** Consisten en simular datos de entrada, para comprobar que los resultados sean correctos. Dado el caso de que no coincidan los datos se debe revisar el anÃ¡lisis del problema y el cÃ³digo del algoritmo para aplicar las respectivas correcciones y repetir la prueba de escritorio hasta obtener los datos de salida esperados o correctos.

  ğŸ‘‰ Ejemplo: [Ejemplo empleando los tres elemtos revisados en esta secciÃ³n.](./EjemploDiagrama.md)
  
---

### ğŸ¤– Algoritmo vs. Programa

* **Algoritmo:** Es la *idea* lÃ³gica y la secuencia de pasos finitos para resolver un problema. Es el "plano" o la "receta".
* **Programa (Software):** Es la *implementaciÃ³n* de ese algoritmo. Es un conjunto de instrucciones escritas en un lenguaje de programaciÃ³n especÃ­fico (como C) que una computadora puede entender y ejecutar.

**El Flujo de CreaciÃ³n (De la Idea al Software):**

> **Problema** â¡ï¸ **Algoritmo** (DiseÃ±o lÃ³gico) â¡ï¸ **CÃ³digo Fuente** (Escritura en C) â¡ï¸ **CompilaciÃ³n** â¡ï¸ **CÃ³digo MÃ¡quina** â¡ï¸ **Programa (Software)**

---

### ğŸ“š Lenguajes de ProgramaciÃ³n

#### Lenguaje de Alto Nivel
Es un lenguaje (como C, Python, Java) que utiliza una sintaxis similar al lenguaje humano, lo que facilita su escritura y lectura. Oculta la complejidad del hardware (el "bajo nivel") y nos permite enfocarnos en la lÃ³gica del problema.

Sus dos categorÃ­as principales de ejecuciÃ³n son:

1.  **Lenguajes Compilados** (Ej: C, C++)
2.  **Lenguajes Interpretados** (Ej: Python, JavaScript)

#### âš™ï¸ Lenguaje Compilado
Un lenguaje compilado requiere un programa llamado **compilador** (en nuestro caso, `gcc`) que traduce *todo* el cÃ³digo fuente en un solo paso, creando un archivo ejecutable que la computadora puede correr directamente.

**Proceso de CompilaciÃ³n:**
> **CÃ³digo Fuente (`.c`)** â¡ï¸ **Compilador (`gcc`)** â¡ï¸ **Programa Objeto (`.o`)** â¡ï¸ **CÃ³digo Ejecutable (`.exe`)**

#### ğŸƒâ€â™‚ï¸ Lenguaje Interpretado
Requiere un programa auxiliar llamado **intÃ©rprete**. En lugar de crear un archivo ejecutable, el intÃ©rprete lee y ejecuta el cÃ³digo fuente *lÃ­nea por lÃ­nea*, traduciendo y ejecutando sobre la marcha.

**Proceso de InterpretaciÃ³n:**
1.  Se traduce una instrucciÃ³n del cÃ³digo fuente.
2.  Se ejecuta dicha instrucciÃ³n.
3.  Se repite el proceso (1 y 2) con todas las instrucciones del cÃ³digo.

---

### âš–ï¸ Compilado vs. Interpretado (Contraste)

Esta tabla resume las diferencias clave que aprendimos:

| CaracterÃ­stica | Lenguaje Compilado (ej. C) | Lenguaje Interpretado (ej. Python) |
| :--- | :--- | :--- |
| **TraducciÃ³n** | Todo el cÃ³digo de una vez, **antes** de ejecutar. | LÃ­nea por lÃ­nea, **durante** la ejecuciÃ³n. |
| **Resultado** | Un archivo ejecutable (`.exe`). | Ninguno. El cÃ³digo siempre necesita el intÃ©rprete. |
| **Velocidad** | Generalmente **mÃ¡s rÃ¡pido** (ya estÃ¡ traducido). | Generalmente **mÃ¡s lento** (traduce sobre la marcha). |
| **Portabilidad** | Menos portable (el `.exe` es para un S.O.). | MÃ¡s portable (el cÃ³digo corre donde estÃ© el intÃ©rprete). |

---

#### ğŸ§© 2. ProgramaciÃ³n por Bloques

Una introducciÃ³n visual y amigable (Â¡como un rompecabezas!) a la lÃ³gica de programaciÃ³n. Usamos herramientas como:

* **ğŸ® Blocky Games:** Sirve para enseÃ±ar programaciÃ³n a principiantes mediante diversos juegos interactivos, por ejemplo el uso de bloques visuales que se encajan, en lugar de cÃ³digo escrito. El objetivo es aprender la lÃ³gica de la programaciÃ³n de forma divertida y sin frustraciÃ³n.
  
  - [Blocky Games](https://blockly.games/?lang=en)

    En esta imagen se observa los juegos con los que cuenta este softwar, estos desafÃ­os nos ayudan a formar una base para entrar a la lÃ³gica de programaciÃ³n.
    
<p align="center">
<img width="886" height="444" alt="image" src="https://github.com/user-attachments/assets/db419a71-7b12-42e3-a44b-d3eb428bab18" />
  <br>
  <em><b>Figura 7:</b> DesafÃ­os de Blocky Games.</em>
</p>

* **ğŸ§± Pilas Bloques:** Sirve para entender bucles, condicionales y eventos de una manera visual e intuitiva. Sin la frustraciÃ³n de la sintaxis.
  
  - [Pilas Bloques](https://pilasbloques.program.ar/online/#/)

    A diferencia de "Blocky Games" esta herramienta tiene un solo tipo de juego que son los laberintos, los cuales cuentan con tres niveles: Principiante, Intermedio y Avanzado.
    
<p align="center">
  <img width="1917" height="969" alt="image" src="https://github.com/user-attachments/assets/0ae3b062-a8ee-4a7e-9ebc-3d00623565bb" />
  <br>
  <em><b>Figura 8:</b> DesafÃ­os de Pilas Bloques</em>
</p>

---

#### â¡ï¸ 3. Ejemplos de Algoritmos con Estructuras Lineales/Secuenciales

**ğŸ› ï¸ Herramienta usadas:**
 **1. PSeInt**

<p align="center">
<img width="140" height="146" alt="image" src="https://github.com/user-attachments/assets/0e048d5c-9191-47fd-9eac-832c0132850f" />

<p align="center"><em><b>Figura 9:</b> Logo PSeInt.</em>
</p>

PSeInt fue la herramienta fundamental para construir y probar nuestra lÃ³gica de programaciÃ³n. Es un software educativo diseÃ±ado especÃ­ficamente para aprender los fundamentos de la algoritmia utilizando un **pseudocÃ³digo** estructurado en espaÃ±ol. Su funciÃ³n principal fue permitirnos diseÃ±ar soluciones algoritmos enfocÃ¡ndonos puramente en la lÃ³gica de **Entrada, Proceso y Salida,** sin la complejidad sintÃ¡ctica de un lenguaje formal. Lo mÃ¡s Ãºtil fue su intÃ©rprete, que nos obligaba a seguir reglas sintÃ¡cticas simples (como definir variables o usar `Escribir` y `Leer`), detectando errores lÃ³gicos al instante. AdemÃ¡s, PSeInt nos permitiÃ³ **generar y visualizar diagramas de flujo** automÃ¡ticamente a partir de nuestro pseudocÃ³digo, ayudÃ¡ndonos a entender la secuencia y el flujo de las instrucciones de una manera grÃ¡fica.

 **2. Visual Studio Code (lenguaje C)**

<p align="center">
 <img width="90" height="90" alt="image" src="https://github.com/user-attachments/assets/4330edfd-e0f6-43de-ab1d-7258370981f3" />

<p align="center"><em><b>Figura 10:</b> Logo PSeInt.</em>
</p>

Visual Studio Code (VS Code) fue el entorno de desarrollo que utilizamos para programar en el lenguaje de alto nivel C. Como editor de cÃ³digo, su funciÃ³n principal fue facilitarnos la escritura del cÃ³digo fuente, el cual debe guardarse obligatoriamente con la extensiÃ³n `.c`. Para que un programa en C funcione, aprendimos que es fundamental incluir **librerÃ­as** usando la directiva `#include`. Estas librerÃ­as (archivos `.h`) proveen funciones esenciales, siendo la librerÃ­a base `#include <stdio.h>` la mÃ¡s importante, ya que contiene las funciones de entrada y salida.

Toda la lÃ³gica del programa debe escribirse dentro de la funciÃ³n principal `int main() { ... }`, que es el punto de inicio de la ejecuciÃ³n. Dentro de esta funciÃ³n, definimos variables con sus tipos de datos (como `int`, `char`, `float` o `double`) y cada instrucciÃ³n debe finalizar obligatoriamente con un punto y coma (`;`). Para la entrada y salida, en lugar de `Leer` y `Escribir` de PSeInt, usamos `printf()` para mostrar datos y `scanf()` para leerlos. Ambas funciones requieren **"mÃ¡scaras"** (especificadores de formato) para saber quÃ© tipo de dato manejar, como `%d` para enteros, `%f` para flotantes, `%c` para caracteres o `%s` para cadenas. Un detalle crucial de `scanf()` es que exige el uso del ampersand (`&`)antes del nombre de la variable para poder guardar el dato en su direcciÃ³n de memoria.

Finalmente, la **terminal integrada** de VS Code nos permitiÃ³ compilar el programa usando `gcc ./nombre_archivo.c -o nombre_archivo` y ejecutarlo con `./nombre_archivo.exe`, centralizando todo el ciclo de desarrollo en una sola interfaz.

#### â¡ï¸ 4. Ejemplos de Algoritmos con Estructuras Lineales/Secuenciales (PSeInt y VS Code)

Son algoritmos directos, como una lista de tareas. Se ejecuta el paso 1, luego el 2, luego el 3, sin desvÃ­os ni repeticiones.

A continuaciÃ³n, se presentan 3 ejemplos prÃ¡cticos desarrollados en PSeInt (para la lÃ³gica) y en C (para la implementaciÃ³n).

#### ğŸš— Ejemplo 1: CÃ¡lculo de AceleraciÃ³n
* **ğŸ—’ï¸ DescripciÃ³n:** Un algoritmo que solicita al usuario las velocidades (inicial y final) y el tiempo, para calcular y mostrar la aceleraciÃ³n resultante.
* **ğŸ”— Enlaces:**
  * [Ver en PSeInt ğŸ’»](calculoAceleracion.psc)
  * [Ver en C ğŸ”µ](calculoAceleracion.c)

---

#### ğŸ”¢ Ejemplo 2: Doble y Triple de un NÃºmero
* **ğŸ—’ï¸ DescripciÃ³n:** Un ejercicio bÃ¡sico que lee un nÃºmero ingresado por el usuario y simplemente muestra en pantalla cuÃ¡l es su valor doble y su valor triple.
* **ğŸ”— Enlaces:**
  * [Ver en PSeInt ğŸ’»](dobleYTriple.psc)
  * [Ver en C ğŸ”µ](dobleYTriple.c)

---

#### âœ‚ï¸ Ejemplo 3: DescomposiciÃ³n de un NÃºmero Real
* **ğŸ—’ï¸ DescripciÃ³n:** Este algoritmo toma un nÃºmero con decimales (ej: `12.35`) y lo procesa para mostrar por separado su parte entera (`12`) y su parte decimal (`0.35`).
* **ğŸ”— Enlaces:**
  * [Ver en PSeInt ğŸ’»](separarDecimales.psc)
  * [Ver en C ğŸ”µ](separarDecimales.c)

---

### ğŸš§ 5. Principales Dificultades en la AplicaciÃ³n

Durante el desarrollo de los trabajos de esta unidad, me encontrÃ© con algunas dificultades:

* En PSeInt, al principio fue algo difÃ­cil aprender a "traducir" el enunciado de un problema a un pseudocÃ³digo estructurado. Era confuso diferenciar claramente quÃ© datos debÃ­a pedir (Entrada).
  
* Al programar en C, se me complicÃ³ recordar los especificadores de formato (`%f`, `%d`) y tambiÃ©n cÃ³mo y cuÃ¡ndo usarlos.
  
* En C es un poco mÃ¡s complicado ejecutar el programa, porque primero hay que compilar y luego ejecutar, usando dos comandos especÃ­ficos para cada acciÃ³n.
  
* Pude notar que PSeInt te avisa de un error de sintaxis casi al instante. En cambio, en C, no te marca el error al momento de desarrollar el algoritmo, sino que este aparece al momento de compilar. En ese punto, no puedes avanzar, sale el error y nuevamente tienes que corregir y volver a compilar.

---

### ğŸ’¡ 6. ReflexiÃ³n CrÃ­tica de los Aprendizajes

Al terminar esta primera unidad, mi mayor aprendizaje es que la programaciÃ³n no se trata de memorizar comandos, sino de saber pensar y diseÃ±ar una soluciÃ³n antes de codificar. ComprendÃ­ el valor real de PSeInt, no solo como una herramienta para principiantes, sino como una forma de ordenar y validar la lÃ³gica del algoritmo, definiendo claramente la Entrada, el Proceso y la Salida.

Posteriormente, en C, apliquÃ© esta misma lÃ³gica, pero ahora enfocÃ¡ndome en traducirla a la sintaxis formal que el lenguaje requiere.

En resumen, esta unidad fue clave porque me enseÃ±Ã³ a diseÃ±ar la lÃ³gica pura (PSeInt) y luego aplicarla a la sintaxis formal (C). Este proceso de conectar la lÃ³gica con el cÃ³digo fue mucho mÃ¡s sencillo de comprender gracias a los recursos y explicaciones proporcionadas por la maestra.

---

## ğŸš€ Tareas Entregadas

### ğŸ“š 1. Aprendizaje AutÃ³nomo (AA)

Actividades enfocadas en la auto-investigaciÃ³n, prÃ¡ctica y profundizaciÃ³n de los temas.

#### ğŸ“¦ Tarea 1: Herramientas de Algoritmos (PseudocÃ³digo y Diagramas de Flujo)
* **ğŸ—’ï¸ DescripciÃ³n:** InvestigaciÃ³n sobre una de las principales herramientas de software "PSeInt" para la creaciÃ³n de algoritmos y diagramas de flujo.
* **ğŸ”— Enlace:** [Ver Tarea 1 AA (PDF)](https://drive.google.com/file/d/1_StfZ-StG6K8hbjwmIEVGKtvgRwnL4AS/view?usp=sharing)

#### ğŸ”§ Tarea 2: InstalaciÃ³n de Lenguajes de ProgramaciÃ³n (C, Python o Java)
* **ğŸ—’ï¸ DescripciÃ³n:** Informe con capturas de pantalla que evidencian la correcta instalaciÃ³n y configuraciÃ³n del entorno de desarrollo GCC para C y la ejecuciÃ³n del primer programa 'Hola Mundo'.
* **ğŸ”— Enlace:** [Ver Tarea 2 (PDF)](https://drive.google.com/file/d/15fUyBEn_aVvRdZ6SXHOGYWUv4eWIN-n6/view?usp=sharing)

---

### ğŸ”¬ 2. Aprendizaje PrÃ¡ctico Experimental (APE)

Tareas diseÃ±adas para aplicar los conocimientos teÃ³ricos en escenarios prÃ¡cticos y controlados.

#### âŒ¨ï¸ Tarea 1: Primer Acercamiento a Estructuras Secuenciales en PseudocÃ³digo
* **ğŸ—’ï¸ DescripciÃ³n:** Desarrollo de 1 algoritmo utilizando PSeInt que involucra Ãºnicamente estructuras secuenciales (cÃ¡lculo del Ãndice de Masa Corporal (IMC)).
* **ğŸ”— Enlace:** [Ver Tarea 1 APE (PDF)](https://drive.google.com/file/d/1mm-74-xZGY1PQrObL97xhwyEsw5ilNHe/view?usp=sharing)

#### ğŸ§¬ Tarea 2: Del DiseÃ±o del Algoritmo a la ConstrucciÃ³n del Programa
* **ğŸ—’ï¸ DescripciÃ³n:** Ejercicio completo que muestra el proceso desde el diseÃ±o (en PSeInt) de un problema hasta su implementaciÃ³n final en un lenguaje de programaciÃ³n formal (C).
* **ğŸ”— Enlace:** [Ver Tarea 2 APE (PDF)](https://drive.google.com/file/d/1EiVzkR2qXhUvzrJjp4dQPbFgn-iWF94p/view?usp=sharing)

